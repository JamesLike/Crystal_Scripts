#!/bin/bash

SYMM=" 19"
cell=' 39.440   74.190   78.840  90.00  90.00  90.00 '
$scalmin 
$resmax


$model_F= #Dark Fs
$bin_nam


$phenix_multiscale=$name"_phenix_multiscale.mtz"
TMPHKL=tmp.hkl
OUTFILE1=`echo $HKL_FILENAME | sed -e 's/\.hkl$/_old_truncate.mtz/'`
OUTFILE2=`echo $HKL_FILENAME | sed -e 's/\.hkl$/_new_truncate.mtz/'`
OUTFILE3=`echo $HKL_FILENAME | sed -e 's/\.hkl$/_phenix_massage.mtz/'`
OUTFILE4=`echo $HKL_FILENAME | sed -e 's/\.hkl$/_phenix.mtz/'`
BASENAME=`echo $HKL_FILENAME | sed -e 's/\.hkl$//'`

#  /mnt/data4/XFEL/LR23/DED_tests/scripts/trunc_all_options.sh $f $resmax $resmin "$cell"
#=======================
# Convert hkl to mtz
#=======================

grep -v "^End of reflections" $HKL_FILENAME | grep -v "^Generated by CrystFEL" | grep -v "process_hkl" | grep -v "indexamajig " | grep -v "^partialator" | grep -v "^Audit information from stream" | grep -v "^Indexing methods selected" | grep -v "Re-indexed" | grep -v "ambigator" | grep -v "^/opt/pxsoft/crystfel/" > $TMPHKL

echo "Running 'f2mtz'..."

f2mtz HKLIN $TMPHKL HKLOUT tmp.mtz >> ${BASENAME}_f2mtz_out.html << EOF
TITLE Reflections from CrystFEL
NAME PROJECT XFEL CRYSTAL Kiiro DATASET LR23
CELL${cell}
SYMM${SYMM}
SKIP 3
LABOUT H K L IMEAN SIGIMEAN
CTYPE  H H H J     Q
FORMAT '(3(F4.0,1X),F10.2,10X,F10.2)'
EOF

###
# Convert Intsnsities to F_obs..
###

#phenix.reflection_file_converter tmp.mtz --mtz=$OUTFILE3 --non_anomalous --write_mtz_amplitudes --mtz_root_label=F  --massage_intensities --resolution=$resmax > ${BASENAME}_phenix_massage.log
#phenix.xtriage file $OUTFILE3 > ${BASENAME}_phenix_massage.log
ctruncate -mtzin tmp.mtz -mtzout $OUTFILE2 -colin '/*/*/[IMEAN,SIGIMEAN]' -nres 238 > ${BASENAME}_ctruncate.log

#=======================
# Make Marius' Q-weighted maps
#=======================
make_dmap4_James_edited.sh $dark_model $dark_FC $dark_obs $light_obs $mapmin $resmax $name "$space_group"

phasmin=12.0
# phase file must be calculated from refined model in dark
# folder
# dump the file and add column with 1.0 as sigmas 
mtz2various HKLIN $model_F  HKLOUT model_phs.hkl << mtz_phs
     LABIN FP=FCalc PHIC=PHIC_calc
     OUTPUT USER '(3I5,F12.3,'  1.00  ',F12.3)'
mtz_phs
# get the phase file with added sig column into the system
f2mtz HKLIN model_phs.hkl HKLOUT FC_dark.mtz << f2m_phs 
CELL${cell}
SYMM${SYMM}
LABOUT H   K  L   FC_D SIG_FC_D PHI_D
CTYPE  H   H  H   F     Q        P
f2m_phs

cad HKLIN1 FC_dark.mtz HKLIN2 $dark_obs HKLIN3 $light_obs HKLOUT all.mtz << END-cad
LABIN FILE 1 E1=FC_D E2=SIG_FC_D E3=PHI_D
CTYP  FILE 1 E1=F E2=Q E3=P 
LABIN FILE 2 E1=F E2=SIGF
CTYP  FILE 2 E1=F E2=Q
LABO FILE 2 E1=F_Dark E2=SIGF_Dark
LABIN FILE 3 E1=F E2=SIGF
LABO FILE 3 E1=F_${bin_nam} E2=SIGF_${bin_nam}
CTYP  FILE 3 E1=F E2=Q
END
END-cad

scaleit HKLIN all.mtz HKLOUT all_sc1.mtz << END-scaleit1
TITLE FPHs scaled to FP
reso $scalmin $resmax      # Usually better to exclude lowest resolution data
EXCLUDE FP SIG 4 FMAX 10000000
REFINE ANISOTROPIC 
LABIN FP=FC_D SIGFP=SIGF_Dark  -
  FPH1=F_Dark SIGFPH1=SIGF_Dark -
  FPH2=F_${bin_nam} SIGFPH2=SIGF_${bin_nam}
CONV ABS 0.0001 TOLR  0.000000001 NCYC 150
END
END-scaleit1

echo " SCALEIT OVER,  CHECK "

#goto fhscal

scaleit HKLIN all_sc1.mtz HKLOUT all_sc2.mtz  << END-scaleit2
TITLE FPHs scaled to FP
reso $scalmin $resmax      # Usually better to exclude lowest resolution data
REFINE ANISOTROPIC 
EXCLUDE FP SIG 4 FMAX 10000000
LABIN FP=F_Dark SIGFP=SIGF_Dark -
  FPH1=F_${bin_nam} SIGFPH1=SIGF_${bin_nam}
CONV ABS 0.0001 TOLR  0.000000001 NCYC 40
END
END-scaleit2

cp all_sc2.mtz scale_it.mtz
echo "unweighted maps"

fft HKLIN all_sc2.mtz MAPOUT ${bin_nam}_nonw.map << endfft
  RESO $mapmin  $resmax
  GRID 200 200 120
  BINMAPOUT
  LABI F1=F_${bin_nam} SIG1=SIGF_${bin_nam} F2=F_Dark SIG2=SIGF_Dark PHI=PHI_D
endfft
# dump the scaled files to calculate the weighted map
mtz2various HKLIN all_sc2.mtz  HKLOUT light_scaled.hkl << end_mtzv1
     LABIN FP=F_${bin_nam} SIGFP=SIGF_${bin_nam}
     OUTPUT USER '(3I5,2F12.3)'
     RESOLUTION 60.0 $resmax 
end_mtzv1
mtz2various HKLIN all_sc2.mtz  HKLOUT dark_scaled.hkl << end_mtzv2
     LABIN FP=F_Dark SIGFP=SIGF_Dark
     OUTPUT USER '(3I5,2F12.3)'
     RESOLUTION 60.0 $resmax 
end_mtzv2
mtz2various HKLIN all_sc2.mtz  HKLOUT dark_phase.hkl << end_mtzv3
     LABIN FP=FC_D SIGFP=SIG_FC_D PHIC=PHI_D
     OUTPUT USER '(3I5,3F12.3)'
     RESOLUTION $phasmin $resmax 
end_mtzv3
# this is the wmar.inp file
echo light_scaled.hkl > wmar.inp
echo dark_scaled.hkl >> wmar.inp
echo dark_phase.hkl >> wmar.inp
echo ${bin_nam}_dark.phs >> wmar.inp
# this will produce a difference structure factor file
# h k l DF weight Phase
# run weighting program
echo "weighting"
~/progs/marius/scripts/PROGS/weight_zv2 < wmar.inp
f2mtz HKLIN ${bin_nam}_dark.phs HKLOUT ${bin_nam}_dwt.mtz << end_weight 
CELL${cell}
SYMM${SYMM}
LABOUT H   K  L   DOBS_${bin_nam}  FOM_${bin_nam}  PHI
CTYPE  H   H  H   F      W   P
END
end_weight
#calculate weighted difference map
fft HKLIN ${bin_nam}_dwt.mtz MAPOUT ${bin_nam}_wd.map << END-wfft
  RESO $mapmin  $resmax 
  GRID 200 200 120
  BINMAPOUT
  LABI F1=DOBS_${bin_nam} W=FOM_${bin_nam} PHI=PHI
END-wfft
mapmask mapin ${bin_nam}_wd.map mapout ${bin_nam}_wdex.map xyzin $dark_model << ee
extend xtal
border 0.0
ee
#=======================
#Phenix multiscale
#=======================
phenix.fobs_minus_fobs_map f_obs_1_file=$light_obs f_obs_2_file=$dark_obs phase_source=$dark_model multiscale=True output_file=$phenix_multiscale
phenix.mtz2map mtz_file=$phenix_multiscale #This actually has two options for how it scales the map - either by sigmas (the defult) of by volume (alterntive options it seems not to make a diffrence which is used. 
rm logfile.log tmp.hkl tmp.mtz
#=======================
#Extract and align Phenix Fs
#=======================
phenix.python /mnt/data4/XFEL/LR23/DED_tests/scripts/call.py f_obs_1_file=$light_obs f_obs_2_file=$dark_obs phase_source=$dark_model multiscale=True output_file=phenix_Fobs_Fobs.mtz 
mv /tmp/fobs1 ./fobs_light 
mv /tmp/fobs2 ./fobs_dark 
mv /tmp/fmodel ./fmodel
#Make the light obs data into an hkl ascii to play with.. 
mtz2various HKLIN $light_obs  HKLOUT light.hkl << light_to_hkl >> mtz_log
     LABIN FP=F SIGFP=SIGF
     OUTPUT USER '(3I5,F12.3,F12.3)'
light_to_hkl
#Then match it and sort into a single hkl file of format: h,k,l,fobs scaled,fobs unscaled, sigf unscaled, sigf scaledl
awk '{print $1,$2,$3,"c",$4}' fobs_light > tmp_light_1
awk '{print $1,$2,$3,"c",$4,$5}' light.hkl > tmp_light_2
sort -tc -n tmp_light_1 > tmp_light_1a
sort -tc -n tmp_light_2 > tmp_light_2a
join -tc -j 1 -o 1.1 1.2 2.2 tmp_light_1a tmp_light_2a > tmp_light_12a
sed 's/c/ /g' < tmp_light_12a > light_Fs 
awk '{$7 = ($6 != 0) ? sprintf("%.3f", $4 * $6 / $5) : "UND"}1' light_Fs > light_Fs_scaled
#Then need to format correctly: hkl format should be columns of 5,5,5,12,12 for hkl fobs sigfobs
awk '{printf "%5i%5i%5i%12.3f%12.3f \n",$1, $2, $3, $4, $7}' light_Fs_scaled > light_Fs_scaled.hkl
#rm tmp_light_1 tmp_light_2 tmp_light_1a tmp_light_2a tmp_light_12a light_Fs light_Fs_scaled light.hkl

# Now generate the dark equiverlent - shouldnt nee to ortder the dark and light hkls as they should already be compared by phenix
mtz2various HKLIN $dark_obs  HKLOUT dark.hkl << dark_to_hkl  >> mtz_log
     LABIN FP=F SIGFP=SIGF
     OUTPUT USER '(3I5,F12.3,F12.3)'
dark_to_hkl

#Then match it and sort into a single hkl file of format: h,k,l,fobs scaled,fobs unscaled, sigf unscaled, sigf scaledl
awk '{print $1,$2,$3,"c",$4}' fobs_dark > tmp_dark_1
awk '{print $1,$2,$3,"c",$4,$5}' dark.hkl > tmp_dark_2
sort -tc -n tmp_dark_1 > tmp_dark_1a
sort -tc -n tmp_dark_2 > tmp_dark_2a
join -tc -j 1 -o 1.1 1.2 2.2 tmp_dark_1a tmp_dark_2a > tmp_dark_12a
sed 's/c/ /g' < tmp_dark_12a > dark_Fs 
# Then want to scale each SIGF by the same scale used to scale each F (ha ve a check to not divide by 0) 
awk '{$7 = ($5 != 0) ? sprintf("%.3f", $4 * $6 / $5) : "UND"}1' dark_Fs > dark_Fs_scaled 
#Then need to format correctly: hkl format should be columns of 5,5,5,12,12 for hkl fobs sigfobs
awk '{printf "%5i%5i%5i%12.3f%12.3f \n",$1, $2, $3, $4, $7}' dark_Fs_scaled > dark_Fs_scaled.hkl
#rm tmp_dark_1 tmp_dark_2 tmp_dark_1a tmp_dark_2a tmp_dark_12a dark_Fs dark.hkl  #dark_Fs_scaled

# now need to generate a model file which should be of format hkl F_model SIGF=1 phase
mtz2various HKLIN $dark_FC  HKLOUT dark_phases.hkl << dark_FCs >> mtz_log
     LABIN FP=FC_ALL PHIC=PHIC_ALL
     OUTPUT USER '(3I5,F12.3,'  1.00  ',F12.3)'
dark_FCs
# And match it to the relfelction in the fobs
awk '{print $1,$2,$3,"c"}' dark_Fs_scaled.hkl > tmp_dark_phase_1
awk '{print $1,$2,$3,"c",$4,$5,$6}'  dark_phases.hkl > tmp_dark_phase_2
sort -tc -n tmp_dark_phase_1 > tmp_dark_phase_1a
sort -tc -n tmp_dark_phase_2 > tmp_dark_phase_2a
join -tc -j 1 -o 2.1 2.2 tmp_dark_phase_1a tmp_dark_phase_2a > tmp_dark_phase_12a
sed 's/c/ /g' < tmp_dark_phase_12a > dark_phases
awk '{printf "%5i%5i%5i%12.3f%12.3f%12.3f \n",$1, $2, $3, $4, $5, $6}' dark_phases > dark_phases_sorted.hkl

awk '{print $1 ,$2,$3,"c",$4,"c",$6}' dark_phases_sorted.hkl > dFC_tmp1 #hkl FC PHFC
awk '{print $1 ,$2,$3,"c",$4,"c",$5}' dark_Fs_scaled.hkl > DFs_tmp1 #hkl F_DARK_OBS SIG_F_DARK_OBS
awk '{print $1 ,$2,$3,"c",$4,"c",$5}' light_Fs_scaled.hkl > LFs_tmp1 #hkl F_LIGHT_OBS SIG_F_LIGHT_OBS
join -tc -j 1 -o 1.1 1.2 1.3 2.2 2.3 dFC_tmp1 DFs_tmp1 > dFC_DFs_tmp1
join -tc -j 1 -o 1.1 1.2 1.3 1.4 1.5 2.2 2.3 dFC_DFs_tmp1 LFs_tmp1 > dFC_DFs_LFs_tmp1 #Gives: hkl FC PHFC DARK_OBS SIG_F_DARK_OBS F_LIGHT_OBS SIG_F_LIGHT_OBS
sed 's/c/ /g' < dFC_DFs_LFs_tmp1 > dFC_DFs_LFs_tmp2 # remove colmn seperateors 
awk '{printf "%5i%5i%5i%12.3f%12.3f%12.3f%12.3f%12.3f%12.3f \n",$1, $2, $3, $4, $5, $6, $7, $8, $9}' dFC_DFs_LFs_tmp2 > all_Fs.hkl
###################################
# Run my python script.. will output diff_map.dat and Fext_map.dat which should be turned into hklthen mtz then map.. 
###################################
rm neg_int.dat COUNT.dat
COUNTER=1
while [ $COUNTER -le 200 ]
do
	COUNT=$(echo "scale=2; $COUNTER/10" | bc -l)
	echo "Processing $COUNT"

	python ${script_loc}scripts/own_scales/extended_map.py $COUNT
	awk '{printf "%5i%5i%5i%12.3f%12.3f%12.3f \n",$1, $2, $3, $4, $5, $6}' Fext_map.dat > Fext_map.hkl #hkl phFC Fext, sigFext
	awk '{printf "%5i%5i%5i%12.3f%12.3f%12.3f \n",$1, $2, $3, $4, $5, $6}' Fext_unw_map.dat > Fext_unw_map.hkl #hkl phFC Fext, sigFext
################
# Turn the extended hkls into mtz then into a map (named neg_map.map) which is fed to the negative integration script (M Scmidt)
################
f2mtz HKLIN Fext_map.hkl HKLOUT James_ext.mtz >log << end_weight 
CELL${cell}
SYMM${SYMM}
LABOUT H   K  L   PHI  Fext  sigFext
CTYPE  H   H  H   P      F   Q
END
end_weight

fft HKLIN James_ext.mtz MAPOUT neg_map.map  >log << END-wfft 
RESO 15 $resmax
SCALE F1 1.0 0.0
GRID 160 160 140
BINMAPOUT
LABI F1=Fext SIG1=sigFext PHI=PHI
END-wfft

~/scripts/marius/neg_int/neg.sh > neg_${COUNTER}.log 
grep 'SUM NEGATIVE DENSITY :' neg_${COUNTER}.log | awk '{print $5}' >> neg_int.dat
echo $COUNT >> COUNT.dat

mv neg_map.map Fxt_map_${COUNTER}.map
###################################
#Now maqke the unweighted map
###################################
f2mtz HKLIN Fext_unw_map.hkl HKLOUT James_unw_ext.mtz >log << end_weight 
CELL${cell}
SYMM${SYMM}
LABOUT H   K  L   PHI  Fext  sigFext
CTYPE  H   H  H   P      F   Q
END
end_weight

fft HKLIN James_unw_ext.mtz MAPOUT neg_map.map  >log << END-wfft 
RESO 15 $resmax
SCALE F1 1.0 0.0
#GRID 160 160 140
BINMAPOUT
LABI F1=Fext SIG1=sigFext PHI=PHI
END-wfft

~/scripts/marius/neg_int/neg.sh > neg_unw_${COUNTER}.log 
grep 'SUM NEGATIVE DENSITY :' neg_unw_${COUNTER}.log | awk '{print $5}' >> neg_unw_int.dat

mv neg_map.map Fxt_unw_map_${COUNTER}.map
mv James_unw_ext.mtz Fxt_unw_${COUNTER}.mtz
COUNTER=$(( $COUNTER + 10))
done

###################################
#Organise data
###################################
paste COUNT.dat neg_unw_int.dat > neg_unw_count.dat

paste COUNT.dat neg_int.dat  > neg_count.dat
awk '{printf "%5i%5i%5i%12.3f%12.3f%12.3f \n",$1, $2, $3, $4, $5, $6}' diff_unweighted_map.dat > diff_unweighted_map.hkl
awk '{printf "%5i%5i%5i%12.3f%12.3f%12.3f \n",$1, $2, $3, $4, $5, $6}' diff_weight_map.dat > diff_weight_map.hkl #hkl phFC Fext, sigFext

###################################
#Generate the unweighted map
echo "Making unwt map"
###################################
f2mtz HKLIN diff_unweighted_map.hkl HKLOUT diff_unweighted_map.mtz << end_weight  >log
CELL${cell}
SYMM${SYMM}
LABOUT H   K  L   PHDOBS  DOBS  FOM
CTYPE  H   H  H   P      F   W
END
end_weight

fft HKLIN diff_unweighted_map.mtz MAPOUT diff_unweighted_map.map << END-wfft >log
  RESO 15 resmax
  GRID 200 200 120
  BINMAPOUT
  LABI F1=DOBS W=FOM PHI=PHDOBS
END-wfft

###################################
#Generate the weighted map
echo "Making wt map"
###################################
f2mtz HKLIN diff_weight_map.hkl HKLOUT diff_weight_map.mtz << end_weight  >weighted_map_log
CELL${space_group}
SYMM${SYMM}
LABOUT H   K  L   PHDOBS  DOBS  FOM
CTYPE  H   H  H   P      F   W
END
end_weight

fft HKLIN diff_weight_map.mtz MAPOUT diff_weight_map.map << END-wfft >weighted_map_log
  RESO 15 1.4
  GRID 200 200 120
  BINMAPOUT
  LABI F1=DOBS W=FOM PHI=PHDOBS
END-wfft
gnuplot -e "set terminal png size 800,600; set output 'count.png'; set xlabel 'N_{EXT}'; set ylabel 'Integrated negative electron density (arb.)'; set key off ; plot 'neg_count.dat' using 1:(\$2*-1) with linespoints"

#rm Fxt_map*

echo "Run GNUPLOT code to view output:"
echo "plot \"neg_count.dat\" u 1:(\$2*-1) "


added=1
while [ $added -le 200 ]
do
	add=$(echo "scale=2; $added/10" | bc -l)
	echo "Processing " $add
	echo dark_phase.hkl >  add.inp # Dark phases on an absolute scale hkl F sig F phase
	echo ${bin_nam}_dark.phs >> add.inp # Q weighted time-point map: hkl deltF FOM PHI
	echo light_scaled.hkl >> add.inp #  Light scaled structure factors hkl F sigF 
	echo darkFC_extrap.hkl >> add.inp
	echo darkFC_extrap.phs >> add.inp
	echo ${add} >> add.inp
	~/progs/marius/scripts/PROGS/fc+fwv3 < add.inp
	

f2mtz HKLIN darkFC_extrap.hkl HKLOUT marius_ext.mtz >log << end_weight 
#CELL 39.34  74.01  78.62  90  90  90  # angles default to 90
#SYMM 19
CELL${cell}
SYMM${SYMM}
LABOUT H   K  L   Fext  sigF  PHI 
CTYPE  H   H  H   F     Q    P
END
end_weight

fft HKLIN marius_ext.mtz MAPOUT neg_map.map  >log << END-wfft 
RESO 15 $resmax
SCALE F1 1.0 0.0
GRID 160 160 140
BINMAPOUT
LABI F1=Fext SIG1=sigF PHI=PHI
END-wfft



	~/scripts/marius/neg_int/neg.sh > neg_${add}_Mari.log 
	grep 'SUM NEGATIVE DENSITY :' neg_${add}_Mari.log | awk '{print $5}' >> neg_add.dat

#	~/scripts/marius/neg_int/neg_1.sh > neg_${add}_Mari_1.log 
#	grep 'SUM NEGATIVE DENSITY :' neg_${add}_Mari_1.log | awk '{print $5}' >> neg_add_1.dat

#	~/scripts/marius/neg_int/neg_2.sh > neg_${add}_Mari_2.log 
#	grep 'SUM NEGATIVE DENSITY :' neg_${add}_Mari_2.log | awk '{print $5}' >> neg_add_2.dat

#	~/scripts/marius/neg_int/neg_3.sh > neg_${add}_Mari_3.log 
#	grep 'SUM NEGATIVE DENSITY :' neg_${add}_Mari_3.log | awk '{print $5}' >> neg_add_3.dat

	echo $add >> add.dat



mv marius_ext.mtz Fext_${added}.mtz
mv neg_map.map Fext_map_${added}_Mari.map

added=$(( $added + 5))
done

paste add.dat neg_add.dat > neg_count_Mari.dat

gnuplot -e "set terminal png size 800,600; set output 'count_Mari.png'; set xlabel 'N_{EXT}'; set ylabel 'Integrated negative electron density (arb.)'; set key off ; plot 'neg_count_Mari.dat' using 1:(\$2*-1) with linespoints"



